<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="UTF-8" />
  <title>Crypto Sniper con Pivot High</title>
  <style>
    body { font-family: sans-serif; padding: 20px; background: #121212; color: #eee; }
    #controls { margin-bottom: 15px; }
    select, input { padding: 5px; margin-right: 10px; }
    button { padding: 6px 12px; cursor: pointer; }
    #status { margin-bottom: 10px; }
    #results .coin { 
      background: #1e1e1e; padding: 10px; margin-bottom: 8px; border-radius: 4px; 
    }
    .exchange-badge { display: inline-block; padding: 2px 6px; border-radius: 3px; color: #fff; margin-bottom: 4px; }
    .exchange-badge.binance { background: #f3ba2f; }
    .exchange-badge.bybit   { background: #f24b2a; }
    .gain { color: #4caf50; }
    a { color: #66b0ff; text-decoration: none; }
    a.exchange-link.bybit   { color: #f24b2a; }
    a.exchange-link.binance { color: #f3ba2f; }
  </style>
</head>
<body>
  <div id="controls">
    <label>
      Timeframe:
      <select id="timeframe">
        <option value="1m">1m</option>
        <option value="5m" selected>5m</option>
        <option value="15m">15m</option>
        <option value="30m">30m</option>
        <option value="1h">1h</option>
        <option value="4h">4h</option>
        <option value="1d">1d</option>
      </select>
    </label>
    <label>
      Threshold (%):
      <input id="threshold" type="number" step="0.1" value="3.0" />
    </label>
    <button id="startBtn">▶ Avvia Analisi</button>
  </div>

  <div id="status">In attesa di avvio...</div>
  <div id="results"></div>

  <script>
    // === CONFIG TELEGRAM ===
    const TELEGRAM_TOKEN   = 'YOUR_TELEGRAM_BOT_TOKEN';
    const TELEGRAMCHATID   = 'YOUR_TELEGRAM_CHAT_ID';

    // === STATO GLOBALE ===
    let allSymbols      = [];
    let currentIndex    = 0;
    const batchSize     = 5;
    let cycleStartTime;
    let wakeLock        = null;

    // === UTILITIES UI ===
    function updateStatus(msg) {
      document.getElementById('status').textContent = msg;
    }

    async function requestWakeLock() {
      if ('wakeLock' in navigator) {
        try { wakeLock = await navigator.wakeLock.request('screen'); }
        catch (e) { console.error('WakeLock error:', e); }
      }
    }

    // === FUNZIONE PIVOT HIGH (2,1) ===
    function isPivotHigh(klines, i) {
      if (i < 2 || i + 1 >= klines.length) return false;
      const h0 = parseFloat(klines[i][2]);   // high corrente
      const h1 = parseFloat(klines[i-1][2]); // high t-1
      const h2 = parseFloat(klines[i-2][2]); // high t-2
      const hF = parseFloat(klines[i+1][2]); // high t+1
      return (h0 > h1 && h0 > h2 && h0 > hF);
    }

    // === FUNZIONI LINK ===
    function getTradingViewInterval(interval) {
      const map = { '1m':'1','5m':'5','15m':'15','30m':'30','1h':'60','4h':'240','1d':'1D','1w':'1W','1M':'1M' };
      return map[interval] || '5';
    }
    function getTradingViewLink(symbol, interval, exchange='BINANCE') {
      const tvI = getTradingViewInterval(interval);
      return {
        deepLink: null,
        fallback: `https://www.tradingview.com/chart/?symbol=${exchange}:${symbol}&interval=${tvI}&theme=dark`
      };
    }
    function getExchangeLink(symbol, exchange) {
      if (exchange.toLowerCase()==='binance') {
        const base = symbol.replace("USDC","");
        return { deepLink: null, fallback: `https://www.binance.com/en/trade/${base}_USDC` };
      }
      if (exchange.toLowerCase()==='bybit') {
        return { deepLink: null, fallback: `https://www.bybit.com/en/trade/spot/${symbol}` };
      }
      return { deepLink: null, fallback: "#" };
    }
    function launchApp(deepLink, fallback) {
      window.open(fallback, "_blank");
    }

    // === ANALISI BINANCE ===
    async function getBinanceMaxGain(symbol, tf, threshold) {
      try {
        const res  = await fetch(`https://api.binance.com/api/v3/klines?symbol=${symbol}&interval=${tf}&limit=6`);
        const data = await res.json();
        if (!data || data.length < 6) return null;

        let maxGain    = -Infinity;
        let bestCandle = null;

        for (let i = 1; i <= 5; i++) {
          if (!isPivotHigh(data, i)) {
            console.log(`Binance ${symbol} candela ${i}: non pivot high`);
            continue;
          }
          const open  = parseFloat(data[i][1]);
          const close = parseFloat(data[i][4]);
          const gain  = ((close - open) / open) * 100;
          console.log(`Binance ${symbol} candela ${i} (Pivot High): gain=${gain.toFixed(2)}%`);
          if (gain > maxGain) {
            maxGain    = gain;
            bestCandle = {
              symbol, exchange: 'binance',
              gain: gain.toFixed(2),
              open, close,
              index: i,
              timestamp: new Date(data[i][0]).toLocaleTimeString()
            };
          }
        }

        if (bestCandle && maxGain >= threshold) {
          // aggiungo dailyChange
          try {
            const infoRes = await fetch(`https://api.binance.com/api/v3/ticker/24hr?symbol=${symbol}`);
            const info    = await infoRes.json();
            bestCandle.dailyChange = parseFloat(info.priceChangePercent).toFixed(2);
          } catch { bestCandle.dailyChange = "N/A"; }

          // link
          const tv = getTradingViewLink(symbol, tf, 'BINANCE');
          const ex = getExchangeLink(symbol, 'binance');
          bestCandle.tradingViewUrl = tv.fallback;
          bestCandle.exchangeUrl    = ex.fallback;

          if (canSendAlert(symbol)) sendTelegramAlert(bestCandle, tf);
          return bestCandle;
        }
        return null;
      } catch (e) {
        console.error('Errore Binance per', symbol, e);
        return null;
      }
    }

    // === ANALISI BYBIT ===
    async function getBybitMaxGain(symbol, tf, threshold) {
      try {
        const byInt = getTradingViewInterval(tf).toLowerCase();
        const res   = await fetch(`https://api.bybit.com/v5/market/kline?category=spot&symbol=${symbol}&interval=${byInt}&limit=6`);
        const data  = await res.json();
        if (data.retCode !== 0 || !data.result?.list || data.result.list.length < 6) return null;

        let klines     = data.result.list.reverse();
        let maxGain    = -Infinity;
        let bestCandle = null;

        for (let i = 1; i <= 5; i++) {
          if (!isPivotHigh(klines, i)) {
            console.log(`Bybit ${symbol} candela ${i}: non pivot high`);
            continue;
          }
          const open  = parseFloat(klines[i][1]);
          const close = parseFloat(klines[i][4]);
          const gain  = ((close - open) / open) * 100;
          console.log(`Bybit ${symbol} candela ${i} (Pivot High): gain=${gain.toFixed(2)}%`);
          if (gain > maxGain) {
            maxGain    = gain;
            bestCandle = {
              symbol, exchange: 'bybit',
              gain: gain.toFixed(2),
              open, close,
              index: i,
              timestamp: new Date(parseInt(klines[i][0])).toLocaleTimeString()
            };
          }
        }

        if (bestCandle && maxGain >= threshold) {
          try {
            const infoRes = await fetch(`https://api.bybit.com/v5/market/ticker?category=spot&symbol=${symbol}`);
            const info    = await infoRes.json();
            const pct     = parseFloat(info.result.list[0].price24hPcnt) * 100;
            bestCandle.dailyChange = pct.toFixed(2);
          } catch { bestCandle.dailyChange = "N/A"; }

          const tv = getTradingViewLink(symbol, tf, 'BYBIT');
          const ex = getExchangeLink(symbol, 'bybit');
          bestCandle.tradingViewUrl = tv.fallback;
          bestCandle.exchangeUrl    = ex.fallback;

          if (canSendAlert(`BYBIT_${symbol}`)) sendTelegramAlert(bestCandle, tf);
          return bestCandle;
        }
        return null;
      } catch (e) {
        console.error('Errore Bybit per', symbol, e);
        return null;
      }
    }

    // === ALERT TELEGRAM ===
    function canSendAlert(key) {
      // placeholder per limitare ripetizioni
      return true;
    }
    async function sendTelegramAlert(data, tf) {
      const icon  = data.exchange === 'bybit' ? '🟠' : '🟡';
      const name  = data.exchange.toUpperCase();
      const quote = data.exchange === 'bybit' ? 'USDT' : 'USDC';
      const msg = `🚨 CRYPTO SNIPER ALERT 🚨
${icon} Exchange: ${name}
🔸 Coin: ${data.symbol}
💰 Quote: ${quote}
🔸 Timeframe: ${tf}
🔸 Gain: ${data.gain}%
📆 24h: ${data.dailyChange}%
🕒 Candela n° ${data.index + 1}
🟢 Open: ${data.open}
🔴 Close: ${data.close}
⏰ Timestamp: ${data.timestamp}
TradingView: ${data.tradingViewUrl}
🔗 ${name} Trading: ${data.exchangeUrl}`;

      const url = `https://api.telegram.org/bot${TELEGRAM_TOKEN}/sendMessage`;
      try {
        await fetch(url, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            chat_id: TELEGRAMCHATID,
            text: msg,
            parse_mode: 'HTML',
            disable_web_page_preview: false
          })
        });
        console.log(`Alert inviato per ${name}:${data.symbol}`);
      } catch (err) {
        console.error('Errore invio Telegram:', err);
      }
    }

    // === LISTE SIMBOLI ===
    async function getBinanceSymbolListForSniper() {
      try {
        const res  = await fetch("https://api.binance.com/api/v3/exchangeInfo");
        const data = await res.json();
        return data.symbols
          .filter(s => s.symbol.endsWith("USDC") && s.status === "TRADING")
          .map(s => s.symbol);
      } catch (e) {
        console.error("Errore Binance lista:", e);
        return [];
      }
    }
    async function getBybitSymbolListForSniper() {
      try {
        const res  = await fetch("https://api.bybit.com/v5/market/instruments-info?category=spot");
        const data = await res.json();
        if (data.retCode===0 && data.result?.list) {
          return data.result.list
            .filter(s => s.symbol.endsWith("USDT") && s.status === "Trading")
            .map(s => s.symbol);
        }
        return [];
      } catch (e) {
        console.error("Errore Bybit lista:", e);
        return [];
      }
    }

    // === APPEND RISULTATI ===
    function appendResult(candle) {
      const container = document.getElementById("results");
      const el = document.createElement("div");
      el.className = `coin ${candle.exchange}`;
      el.innerHTML = `
        <div class="exchange-badge ${candle.exchange}">${candle.exchange.toUpperCase()}</div>
        <div><strong>💰 ${candle.symbol}</strong> ${candle.exchange==='bybit'?'(USDT)':'(USDC)'}</div>
        <div>📊 Gain: <span class="gain">+${candle.gain}%</span> | 📆 24h: ${candle.dailyChange}%</div>
        <div>🕒 Candela n° ${candle.index + 1} | ⏰ ${candle.timestamp}</div>
        <div>🟢 Open: ${candle.open} | 🔴 Close: ${candle.close}</div>
        <div style="margin-top:10px;">
          <a href="#" onclick="launchApp('','${candle.tradingViewUrl}');return false;">📊 TradingView</a>
          &nbsp;
          <a href="#" class="exchange-link ${candle.exchange}"
             onclick="launchApp('','${candle.exchangeUrl}');return false;">
            🔗 ${candle.exchange.toUpperCase()} Trading
          </a>
        </div>`;
      container.appendChild(el);
    }

    // === CICLO PRINCIPALE ===
    async function cycleProcessing() {
      const tf        = document.getElementById("timeframe").value;
      const threshold = parseFloat(document.getElementById("threshold").value) || 3.0;
      document.getElementById("results").innerHTML = "";
      updateStatus("Caricamento simboli...");
      if (!allSymbols.length) {
        const [bn, by] = await Promise.all([
          getBinanceSymbolListForSniper(),
          getBybitSymbolListForSniper()
        ]);
        allSymbols = [
          ...bn.map(s=>({exchange:'binance',symbol:s})),
          ...by.map(s=>({exchange:'bybit',symbol:s}))
        ];
      }
      currentIndex    = 0;
      cycleStartTime  = new Date();
      updateStatus(`Inizio ciclo: 0/${allSymbols.length} elaborati.`);
      await processBatch(tf, threshold);
    }

    async function processBatch(tf, threshold) {
      const total = allSymbols.length;
      const batch = allSymbols.slice(currentIndex, currentIndex + batchSize);

      for (let i = 0; i < batch.length; i++) {
        const { exchange, symbol } = batch[i];
        const fn = exchange==='binance'
                   ? getBinanceMaxGain
                   : getBybitMaxGain;
        const res = await fn(symbol, tf, threshold);
        if (res) appendResult(res);

        const done = currentIndex + i + 1;
        const pct  = ((done/total)*100).toFixed(1);
        const sec  = Math.floor((new Date() - cycleStartTime)/1000);
        updateStatus(`Elaborate ${done}/${total} (${pct}%). Tempo: ${sec}s.`);
        await new Promise(r=>setTimeout(r,60));
      }

      currentIndex += batchSize;
      if (currentIndex < total) {
        await processBatch(tf, threshold);
      } else {
        const totSec = Math.floor((new Date() - cycleStartTime)/1000);
        updateStatus(`Ciclo completato in ${totSec}s. Riavvio tra 3s...`);
        allSymbols = [];
        setTimeout(cycleProcessing,3000);
      }
    }

    // === INIZIALIZZAZIONE ===
    document.getElementById('startBtn').addEventListener('click', cycleProcessing);
    document.addEventListener('visibilitychange', () => {
      if (!document.hidden && wakeLock===null) requestWakeLock();
    });
  </script>
</body>
</html>
```[43dcd9a7-70db-4a1f-b0ae-981daa162054](https://github.com/MasonHalstead/skybase/tree/a39deec95e986c139e04d6bf686222f3fcd40343/services%2Fkraken.js?citationMarker=43dcd9a7-70db-4a1f-b0ae-981daa162054 "1") 
