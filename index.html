<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Crypto Sniper ‚Äì Pivot High & Filtri Persistenti</title>
  <style>
    body { font-family: Arial, sans-serif; background: #111; color: #eee; margin: 0; padding: 10px; }
    .controls { display: flex; flex-wrap: wrap; gap: 10px; margin-bottom: 20px; justify-content: center; }
    .controls label { font-size: 14px; display: flex; align-items: center; gap: 4px; }
    select, input[type=number] { padding: 6px; border-radius: 4px; border: 1px solid #555; background: #333; color: #eee; }
    select[multiple] { height: auto; min-height: 80px; }
    input[type=checkbox] { transform: scale(1.1); }
    button { padding: 6px 12px; border: none; border-radius: 4px; background: #4caf50; color: #fff; cursor: pointer; }
    button:hover { background: #45a049; }
    #status { text-align: center; padding: 8px; margin-bottom: 10px; background: #333; border-radius: 4px; }
    #status.active { background: linear-gradient(90deg,#00ff88,#00cc66); color: #000; }
    #results .coin {
      background: linear-gradient(135deg,#222,#333);
      padding: 12px; margin-bottom: 10px; border-radius: 6px;
      border-left: 4px solid #00ff88; transition: transform .2s, background .3s;
    }
    .coin.bybit { border-color: #f7931a; }
    .coin.binance { border-color: #f3ba2f; }
    .coin:hover { transform: translateX(5px); }
    .coin.alerted { background: rgba(0,255,0,0.2) !important; }
    .exchange-badge { display:inline-block; padding:4px 8px; border-radius:12px; font-size:11px; margin-bottom:8px; }
    .exchange-badge.binance { background:#f3ba2f; color:#000; }
    .exchange-badge.bybit { background:#f7931a; color:#000; }
    .gain { color: #00ff88; font-weight: bold; }
    .tradingview-link, .exchange-link {
      display:inline-block; padding:4px 8px; border-radius:4px; font-size:12px; text-decoration:none; margin-right:6px;
    }
    .tradingview-link { background:#1e88e5; color:#fff; }
    .tradingview-link.checked { background:#ff5722 !important; }
    .exchange-link.binance { background:#f3ba2f; color:#000; }
    .exchange-link.bybit { background:#f7931a; color:#000; }
    .alert-label { display:flex; align-items:center; gap:4px; margin-top:8px; font-size:13px; }
    .alert-indicator { margin-left:6px; }
    .custom-label { display:flex; align-items:center; gap:4px; margin-top:6px; font-size:13px; }
    .custom-threshold { width:70px; padding:4px; background:#333; border:1px solid #555; color:#eee; border-radius:3px; }
    .screenshot-note { margin-top:8px; font-size:12px; color:#aaa; }
  </style>
</head>
<body>
  <h1>üìà Crypto Sniper ‚Äì Pivot High & Filtri Persistenti</h1>
  <div id="status">‚è∏ In attesa di avvio‚Ä¶</div>

  <div class="controls">
    <label>Timeframe:
      <select id="timeframe">
        <option value="1m">1m</option>
        <option value="5m" selected>5m</option>
        <option value="15m">15m</option>
        <option value="30m">30m</option>
        <option value="1h">1h</option>
        <option value="4h">4h</option>
        <option value="1d">1d</option>
      </select>
    </label>

    <label><input type="checkbox" id="enableGain" /> Abilita Filtro Gain</label>
    <label>Soglia Gain (%):
      <input type="number" id="threshold" value="3.0" step="0.1" min="0"/>
    </label>

    <label>Pivot Left (N):
      <input type="number" id="pivotLeft" value="1" step="1" min="1"/>
    </label>
    <label>Pivot Right (M):
      <input type="number" id="pivotRight" value="3" step="1" min="1"/>
    </label>

    <label><input type="checkbox" id="enableDist" checked/> Abilita Distanza Pivot</label>
    <label>Distanza max (%):
      <input type="number" id="distThreshold" value="10.0" step="0.1" min="0" max="100"/>
    </label>

    <label>Soglia Allarme (%):
      <input type="number" id="alertThreshold" value="2.0" step="0.1" min="0"/>
    </label>

    <label>Ordina per (multi-selezione):
      <select id="sortCriteria" multiple size="4">
        <option value="pivotGain">Pivot Gain%</option>
        <option value="dailyChange">% 24h</option>
        <option value="volume">Volume</option>
        <option value="exchange">Exchange</option>
      </select>
    </label>

    <button id="startBtn">‚ñ∂ Avvia Analisi</button>
  </div>

  <div id="results"></div>

  <script>
    // === TELEGRAM CONFIG ===
    const TELEGRAM_TOKEN   = "7919987275:YOUR_TOKEN";
    const TELEGRAM_CHAT_ID = "YOUR_CHAT_ID";

    // === GLOBAL STATE ===
    let allSymbols   = [];
    let currentIndex = 0;
    const batchSize  = 150;
    let cycleStart   = null;
    let wakeLock     = null;
    const resultsMap = new Map();
    const alerted    = new Set();
    const checked    = new Set();
    let cycleCount   = 0;

    // === UI HELPERS ===
    function updateStatus(msg, active = false) {
      const s = document.getElementById('status');
      s.textContent = msg;
      s.className = active ? 'active' : '';
    }
    async function requestWakeLock() {
      if ('wakeLock' in navigator) {
        try { wakeLock = await navigator.wakeLock.request('screen'); }
        catch(e){ console.error(e); }
      }
    }
    document.addEventListener('visibilitychange', () => {
      if (!document.hidden && wakeLock === null) requestWakeLock();
    });

    // === PRICE & PIVOT HELPERS ===
    async function getCurrentPrice(exchange, symbol) {
      if (exchange === 'binance') {
        const res = await fetch(`https://api.binance.com/api/v3/ticker/price?symbol=${symbol}`);
        const j   = await res.json();
        return parseFloat(j.price);
      } else {
        const res = await fetch(`https://api.bybit.com/v5/market/ticker?category=spot&symbol=${symbol}`);
        const j   = await res.json();
        const price = j.result?.list?.[0]?.lastPrice || j.result?.list?.[0]?.price24h;
        return parseFloat(price);
      }
    }
    function isPivotHigh(klines, i, left, right) {
      if (i < left || i + right >= klines.length) return false;
      const h0 = +klines[i][2];
      for (let j = 1; j <= left; j++)
        if (+klines[i-j][2] >= h0) return false;
      for (let k = 1; k <= right; k++)
        if (+klines[i+k][2] >= h0) return false;
      return true;
    }
    function getTradingViewInterval(iv) {
      const m = {'1m':'1','5m':'5','15m':'15','30m':'30','1h':'60','4h':'240','1d':'1D'};
      return m[iv]||'5';
    }
    function getTradingViewLink(sym, iv, ex) {
      return `https://www.tradingview.com/chart/?symbol=${ex}:${sym}&interval=${getTradingViewInterval(iv)}&theme=dark`;
    }
    function getExchangeLink(sym, ex) {
      if (ex==='binance') {
        const b = sym.replace('USDC','');
        return `https://www.binance.com/en/trade/${b}_USDC`;
      }
      if (ex==='bybit') return `https://www.bybit.com/en/trade/spot/${sym}`;
      return '#';
    }
    function launchLink(u){ window.open(u,'_blank'); }

    // === TELEGRAM SENDER ===
    async function sendTelegram(text) {
      const url = `https://api.telegram.org/bot${TELEGRAM_TOKEN}/sendMessage`;
      await fetch(url, {
        method: 'POST',
        headers: {'Content-Type':'application/json'},
        body: JSON.stringify({ chat_id:TELEGRAM_CHAT_ID, text, parse_mode:'HTML' })
      });
    }

    // === MULTI-ORDINAMENTO ===
    function sortResults() {
      const chosen    = Array.from(document.getElementById('sortCriteria').selectedOptions)
                              .map(o => o.value);
      const cont      = document.getElementById('results');
      const items     = Array.from(cont.children);

      items.sort((a, b) => {
        // 1) distanza ascendente (sempre)
        const da = parseFloat(a.querySelector('.distance-value').textContent);
        const db = parseFloat(b.querySelector('.distance-value').textContent);
        if (da !== db) return da - db;

        // 2) applica in PRIORIT√Ä fissa i criteri scelti
        const priority = ['pivotGain','dailyChange','volume','exchange'];
        for (let crit of priority) {
          if (!chosen.includes(crit)) continue;
          let cmp = 0;
          if (crit === 'pivotGain') {
            const va = parseFloat(a.querySelector('.gain').textContent);
            const vb = parseFloat(b.querySelector('.gain').textContent);
            cmp = vb - va;
          }
          if (crit === 'dailyChange') {
            const va = parseFloat(a.querySelector('.daily-change').textContent);
            const vb = parseFloat(b.querySelector('.daily-change').textContent);
            cmp = vb - va;
          }
          if (crit === 'volume') {
            const va = parseFloat(a.querySelector('.volume-value').textContent);
            const vb = parseFloat(b.querySelector('.volume-value').textContent);
            cmp = vb - va;
          }
          if (crit === 'exchange') {
            const ea = a.querySelector('.exchange-badge').textContent;
            const eb = b.querySelector('.exchange-badge').textContent;
            const isA = ea === 'BINANCE';
            const isB = eb === 'BINANCE';
            if (isA && !isB) cmp = -1;
            else if (!isA && isB) cmp = 1;
            else cmp = 0;
          }
          if (cmp !== 0) return cmp;
        }
        return 0;
      });

      items.forEach(el => cont.appendChild(el));
    }

    // === PULIZIA PIVOT STALE ===
    async function removeStalePivots() {
      for (let [key, el] of resultsMap) {
        const oldPivot = parseFloat(el.dataset.pivotVal);
        const [ex, sym] = key.split('|');
        const price     = await getCurrentPrice(ex, sym);
        if (price >= oldPivot) {
          el.remove();
          resultsMap.delete(key);
          alerted.delete(key);
          checked.delete(key);
        }
      }
    }

    // === ALERT CHECK & HIGHLIGHT ===
    function checkAlert(c) {
      const key       = `${c.exchange}|${c.symbol}`;
      const el        = resultsMap.get(key);
      const cb        = el.querySelector('.alert-checkbox');
      const customVal = parseFloat(el.querySelector('.custom-threshold').value) || 0;
      const globalTh  = parseFloat(document.getElementById('alertThreshold').value) || 0;
      const pivotVal  = parseFloat(c.pivotValue);
      const currClose = parseFloat(c.close);
      const distPct   = parseFloat(c.distance);
      const trigger   = customVal > 0
                        ? (pivotVal - currClose) <= customVal
                        : distPct <= globalTh;

      if (cb.checked && trigger && !alerted.has(key)) {
        sendTelegram(
          `üö® <b>${c.symbol}</b> ‚Äì ${c.exchange.toUpperCase()}\n` +
          `PivotHigh: ${c.pivotValue}\n` +
          `Close: ${c.close}\n` +
          `Œî%: ${c.distance}%\n` +
          `<a href="${c.tradingViewUrl}">TradingView</a>`
        );
        alerted.add(key);
        el.querySelector('.alert-indicator').textContent = '‚úÖ';
        el.classList.add('alerted');
      }
    }

    // === UPSERT & UI BUILD ===
    function upsertResult(c) {
      const key = `${c.exchange}|${c.symbol}`;
      const cont = document.getElementById('results');
      let el = resultsMap.get(key);

      if (el) {
        // aggiorna blocco esistente
        el.querySelector('.gain').textContent           = `+${c.gain}%`;
        el.querySelector('.daily-change').textContent   = `${c.dailyChange}%`;
        el.querySelector('.distance-value').textContent = `${c.distance}%`;
        el.querySelector('.volume-value').textContent   = c.volume;
        el.querySelector('.pivottime').textContent      = c.pivotTime;
        el.querySelector('.alert-indicator').textContent= alerted.has(key)?'‚úÖ':'‚ùå';
      } else {
        // crea nuovo blocco
        el = document.createElement('div');
        el.className = `coin ${c.exchange}`;
        el.dataset.pivotVal = c.pivotValue;
        el.innerHTML = `
          <div class="exchange-badge ${c.exchange}">${c.exchange.toUpperCase()}</div>
          <div><strong>üí∞ ${c.symbol}</strong></div>
          <div>üìä Gain: <span class="gain">+${c.gain}%</span> |
               24h: <span class="daily-change">${c.dailyChange}%</span></div>
          <div>üíß Volume: <span class="volume-value">${c.volume}</span></div>
          <div>‚ö° Distance: <span class="distance-value">${c.distance}%</span></div>
          <div>‚öì PivotHigh: ${c.pivotValue} @ <span class="pivottime">${c.pivotTime}</span></div>
          <div>üïí Candela n¬∞${c.index} | ${c.timestamp}</div>
          <div style="margin-top:8px;">
            <a class="tradingview-link" href="#">TradingView</a>
            <a class="exchange-link ${c.exchange}" href="#">Exchange</a>
          </div>
          <label class="alert-label">
            <input type="checkbox" class="alert-checkbox" /> Allarme
            <span class="alert-indicator">‚ùå</span>
          </label>
          <label class="custom-label">
            <input type="number" class="custom-threshold" step="0.1" placeholder="Abs"/> Absolute
          </label>
          <div class="screenshot-note"></div>
        `;
        // click handlers
        el.querySelector('.tradingview-link').addEventListener('click', e => {
          e.preventDefault();
          launchLink(c.tradingViewUrl);
          e.target.classList.add('checked');
          checked.add(key);
        });
        el.querySelector('.exchange-link').addEventListener('click', e => {
          e.preventDefault();
          launchLink(c.exchangeUrl);
        });
        el.querySelector('.alert-checkbox').addEventListener('change', e => {
          if (!e.target.checked) {
            alerted.delete(key);
            el.querySelector('.alert-indicator').textContent = '‚ùå';
            el.classList.remove('alerted');
          }
        });

        resultsMap.set(key, el);
        cont.appendChild(el);
      }

      sortResults();
      checkAlert(c);
    }

    // === FETCH & PIVOT LOGIC ===
    async function getBinanceMaxGain(sym, iv, L, R, gainEn, gainTh, distEn, distTh) {
      try {
        const res  = await fetch(`https://api.binance.com/api/v3/klines?symbol=${sym}&interval=${iv}&limit=6`);
        const data = await res.json();
        if (!Array.isArray(data) || data.length < 6) return null;

        let maxGain = -Infinity, best = null;
        for (let i = 1; i <= 5; i++) {
          if (!isPivotHigh(data, i, L, R)) continue;
          const o = +data[i][1], c = +data[i][4];
          const gain = ((c - o) / o) * 100;
          if (gain > maxGain) {
            maxGain = gain;
            best = { idx:i, open:o, close:c, gain, pivotVal:+data[i][2], pivotTs:+data[i][0], volume:+data[i][5] };
          }
        }
        if (!best) return null;
        if (gainEn && best.gain < gainTh) return null;

        const currentClose = +data.at(-1)[4];
        const distPct      = ((best.pivotVal - currentClose) / best.pivotVal) * 100;
        if (distEn && (currentClose >= best.pivotVal || distPct > distTh)) return null;

        let dailyChange = 'N/A';
        try {
          const info = await fetch(`https://api.binance.com/api/v3/ticker/24hr?symbol=${sym}`);
          const j    = await info.json();
          dailyChange = parseFloat(j.priceChangePercent).toFixed(2);
        } catch {}

        return {
          symbol: sym, exchange:'binance',
          gain: best.gain.toFixed(2), dailyChange,
          volume: best.volume.toFixed(2),
          open: best.open.toFixed(4), close: best.close.toFixed(4),
          pivotValue: best.pivotVal.toFixed(4),
          pivotTime: new Date(best.pivotTs).toLocaleString(),
          distance: distPct.toFixed(2),
          index: best.idx,
          timestamp: new Date(data[best.idx][0]).toLocaleTimeString(),
          tradingViewUrl: getTradingViewLink(sym, iv, 'BINANCE'),
          exchangeUrl:    getExchangeLink(sym, 'binance')
        };
      } catch { return null; }
    }

    async function getBybitMaxGain(sym, iv, L, R, gainEn, gainTh, distEn, distTh) {
      try {
        const mapInt   = {'1m':'1','5m':'5','15m':'15','30m':'30','1h':'60','4h':'240','1d':'D'};
        const interval = mapInt[iv] || '5';
        const res      = await fetch(`https://api.bybit.com/v5/market/kline?category=spot&symbol=${sym}&interval=${interval}&limit=6`);
        const j        = await res.json();
        if (j.retCode !== 0 || !j.result?.list) return null;
        const data = j.result.list.reverse();

        let maxGain = -Infinity, best = null;
        for (let i = 1; i <= 5; i++) {
          if (!isPivotHigh(data, i, L, R)) continue;
          const o = +data[i][1], c = +data[i][4];
          const gain = ((c - o) / o) * 100;
          if (gain > maxGain) {
            maxGain = gain;
            best = { idx:i, open:o, close:c, gain, pivotVal:+data[i][2], pivotTs:+data[i][0], volume:+data[i][5] };
          }
        }
        if (!best) return null;
        if (gainEn && best.gain < gainTh) return null;

        const currentClose = +data.at(-1)[4];
        const distPct      = ((best.pivotVal - currentClose) / best.pivotVal) * 100;
        if (distEn && (currentClose >= best.pivotVal || distPct > distTh)) return null;

        let dailyChange = 'N/A';
        try {
          const info = await fetch(`https://api.bybit.com/v5/market/ticker?category=spot&symbol=${sym}`);
          const k    = await info.json();
          if (k.result.list.length)
            dailyChange = (parseFloat(k.result.list[0].price24hPcnt) * 100).toFixed(2);
        } catch {}

        return {
          symbol: sym, exchange:'bybit',
          gain: best.gain.toFixed(2), dailyChange,
          volume: best.volume.toFixed(2),
          open: best.open.toFixed(4), close: best.close.toFixed(4),
          pivotValue: best.pivotVal.toFixed(4),
          pivotTime: new Date(best.pivotTs).toLocaleString(),
          distance: distPct.toFixed(2),
          index: best.idx,
          timestamp: new Date(data[best.idx][0]).toLocaleTimeString(),
          tradingViewUrl: getTradingViewLink(sym, iv, 'BYBIT'),
          exchangeUrl:    getExchangeLink(sym, 'bybit')
        };
      } catch { return null; }
    }

    // === SYMBOL LIST ===
    async function getBinanceSymbols() {
      const res = await fetch("https://api.binance.com/api/v3/exchangeInfo");
      const j   = await res.json();
      return j.symbols
        .filter(s => s.symbol.endsWith("USDC") && s.status === "TRADING")
        .map(s => s.symbol);
    }
    async function getBybitSymbols() {
      const res = await fetch("https://api.bybit.com/v5/market/instruments-info?category=spot");
      const j   = await res.json();
      return j.result.list
        .filter(s => s.symbol.endsWith("USDT") && s.status === "Trading")
        .map(s => s.symbol);
    }

    // === MAIN CYCLE ===
    async function cycleProcessing() {
      cycleCount++;
      await removeStalePivots();

      currentIndex = 0;
      cycleStart   = Date.now();
      updateStatus(`üîÑ Inizio ciclo ${cycleCount}‚Ä¶`, true);

      if (!allSymbols.length) {
        const [bnb, byb] = await Promise.all([getBinanceSymbols(), getBybitSymbols()]);
        allSymbols = [
          ...bnb.map(s => ({ exchange:'binance', symbol: s })),
          ...byb.map(s => ({ exchange:'bybit',   symbol: s }))
        ];
      }

      const iv     = document.getElementById('timeframe').value;
      const gainEn = document.getElementById('enableGain').checked;
      const gainTh = parseFloat(document.getElementById('threshold').value) || 0;
      const L      = parseInt(document.getElementById('pivotLeft').value) || 1;
      const R      = parseInt(document.getElementById('pivotRight').value) || 3;
      const distEn = document.getElementById('enableDist').checked;
      const distTh = parseFloat(document.getElementById('distThreshold').value) || 100;

      await processBatch(iv, L, R, gainEn, gainTh, distEn, distTh);
    }

    async function processBatch(iv, L, R, gainEn, gainTh, distEn, distTh) {
      const total = allSymbols.length;
      const slice = allSymbols.slice(currentIndex, currentIndex + batchSize);

      for (let i = 0; i < slice.length; i++) {
        const { exchange, symbol } = slice[i];
        const fn = exchange === 'binance'
                   ? getBinanceMaxGain
                   : getBybitMaxGain;
        const res = await fn(symbol, iv, L, R, gainEn, gainTh, distEn, distTh);
        if (res) upsertResult(res);

        const done = currentIndex + i + 1;
        const pct  = ((done / total) * 100).toFixed(1);
        const secs = Math.floor((Date.now() - cycleStart) / 1000);
        updateStatus(`üîÑ Ciclo ${cycleCount} ‚Äì ${done}/${total} (${pct}%) ‚Äì ${secs}s`, true);
        await new Promise(r => setTimeout(r, 50));
      }

      currentIndex += batchSize;
      if (currentIndex < total) {
        await processBatch(iv, L, R, gainEn, gainTh, distEn, distTh);
      } else {
        setTimeout(cycleProcessing, 3000);
      }
    }

    document.getElementById('startBtn').addEventListener('click', cycleProcessing);
  </script>
</body>
</html>
```
