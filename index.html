  <script>
    // --- RACCOLTA SIMBOLI USDC DA BINANCE & BYBIT ---
    async function fetchAllSymbols() {
      const list = [];
      // Binance
      try {
        const res = await fetch('https://api.binance.com/api/v3/exchangeInfo');
        const j   = await res.json();
        j.symbols.forEach(s => {
          if (s.quoteAsset === 'USDC' && s.status === 'TRADING') {
            list.push({ exchange: 'binance', symbol: s.symbol });
          }
        });
      } catch (e) {
        console.error('Binance symbols error', e);
      }
      // Bybit
      try {
        const res = await fetch(
          'https://api.bybit.com/v5/market/symbols?category=spot'
        );
        const j   = await res.json();
        j.result.list.forEach(s => {
          if (s.quoteCoin === 'USDC' && s.status === 'Trading') {
            list.push({ exchange: 'bybit', symbol: s.name });
          }
        });
      } catch (e) {
        console.error('Bybit symbols error', e);
      }
      return list;
    }

    // --- FETCH KLINES UNIFICATE ---
    async function fetchKlines(exchange, symbol, interval, limit) {
      if (exchange === 'binance') {
        const url = `https://api.binance.com/api/v3/klines?symbol=${symbol}`
                  + `&interval=${interval}&limit=${limit}`;
        const res = await fetch(url);
        return await res.json();  // [ [ts, open, high, low, close, vol], ... ]
      } else {
        const url = `https://api.bybit.com/v5/market/kline?category=spot`
                  + `&symbol=${symbol}&interval=${interval}&limit=${limit}`;
        const res = await fetch(url);
        const j   = await res.json();
        // each item: [ts, open, high, low, close, vol, ...]
        return j.result.list.map(o => o.slice(0, 6));
      }
    }

    // --- PROCESSA UN SINGOLO SIMBOLO ---
    async function processSymbol(obj, globalIdx) {
      const tf    = document.getElementById('timeframe').value;
      const left  = +document.getElementById('pivotLeft').value;
      const right = +document.getElementById('pivotRight').value;
      const { exchange, symbol } = obj;

      // fetch klines
      let klines;
      try {
        klines = await fetchKlines(exchange, symbol, tf, left + right + 5);
      } catch {
        return;
      }
      // controllo Pivot High
      if (!isPivotHigh(klines, left, left, right)) return;

      // estrai valori
      const pivotH    = +klines[left][2];
      const pivotTime = new Date(klines[left][0]).toLocaleTimeString();
      const close     = +klines[left][4];
      const dist      = ((close - pivotH) / pivotH * 100).toFixed(2);
      const gain      = dist;
      let dailyChange = 0, volume = 0;

      // 24h change & volume
      try {
        if (exchange === 'binance') {
          const t = await (await fetch(
            `https://api.binance.com/api/v3/ticker/24hr?symbol=${symbol}`
          )).json();
          dailyChange = parseFloat(t.priceChangePercent).toFixed(2);
          volume      = parseFloat(t.volume).toFixed(0);
        } else {
          const t2 = await (await fetch(
            `https://api.bybit.com/v5/market/ticker?category=spot&symbol=${symbol}`
          )).json();
          const pct = parseFloat(t2.result.list[0].price24hPcnt) * 100;
          dailyChange = pct.toFixed(2);
          volume      = parseFloat(t2.result.list[0].volume24h).toFixed(0);
        }
      } catch {
        // ignora errori
      }

      // filtri distanza pivot
      if (document.getElementById('enableDist').checked) {
        const maxD = +document.getElementById('distThreshold').value;
        if (Math.abs(dist) > maxD) return;
      }
      // filtro gain
      if (document.getElementById('enableGain').checked) {
        const minG = +document.getElementById('threshold').value;
        if (+gain < minG) return;
      }

      // prepara dati
      const data = {
        exchange,
        symbol,
        gain,
        dailyChange,
        volume,
        distance: dist,
        pivotValue: pivotH,
        pivotTime,
        index: globalIdx,
        timestamp: new Date().toLocaleTimeString(),
        tradingViewUrl: getTVLink(symbol, tf, exchange),
        exchangeUrl:    getExLink(symbol, exchange)
      };

      upsertResult(data);
    }

    // --- CICLO A BATCH ---
    async function scanNextBatch() {
      const total = allSymbols.length;
      const start = currentIndex;
      const end   = Math.min(start + batchSize, total);

      updateStatus(
        `Scansione ${start + 1}–${end} di ${total} (Ciclo ${cycleCount})`,
        true
      );

      const batch = allSymbols.slice(start, end);
      for (let i = 0; i < batch.length; i++) {
        await processSymbol(batch[i], start + i + 1);
      }

      currentIndex = end;
      if (currentIndex < total) {
        setTimeout(scanNextBatch, 500);
      } else {
        updateStatus(`Ciclo ${cycleCount} completato, riavvio in 5s…`);
        cycleCount++;
        setTimeout(() => {
          currentIndex = 0;
          cycleStart   = Date.now();
          scanNextBatch();
        }, 5000);
      }
    }

    // --- INIZIO SCANSIONE ---
    async function startScan() {
      allSymbols = await fetchAllSymbols();
      currentIndex = 0;
      cycleCount   = 1;
      cycleStart   = Date.now();
      updateStatus(`Avvio ciclo 1…`, true);
      scanNextBatch();
    }

    // --- BOTTONE AVVIO ---
    document.getElementById('startBtn').addEventListener('click', async () => {
      document.getElementById('startBtn').disabled = true;
      await requestWakeLock();
      startScan();
    });
  </script>
</body>
</html>
